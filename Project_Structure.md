# 프로젝트 구조(각 단계별로 테스트 코드를 추가했다.)
## PART I
#### 1. 프로젝트 기본 세팅
1. 커밋 로그 프로토타입 만들기[/LetsGo/internal/server/log.go]
2. HTTP의 JSON 만들기[/LetsGo/internal/server/http.go]
#### 2. 프로토콜 버퍼와 구조체
3. 프로토콜 버퍼로 도메인 자료형 정의하기[/StructureDataWithProtobuf/api/v1/log.proto]
- [/LetsGo/internal/server/log.go] 의 Record 자료형을 protobuf 메시지로 문법에 맞게 바꿔준다.
4. protobuf가 바뀔 때마다 컴파일해야 하므로 Makefile 파일에 compile 이라는 타깃을 만들어두면 편리하다. [/StructureDataWithProtobuf]에 Makefile을 만든다.
#### 3. 로그 패키지 작성
5. 스토어 만들기 : 로그 패키지를 위한 [/internal/log/store.go] 코드를 작성한다. store 구조체는 활성 세그먼트 파일에 접근하는 포인터 필드를 포함한 해당 저장파일에 대한 정보를 가진다. store 구조체를 통해서 레코드를 파일에 기록한다.(로그를 기록할 때 해당 로그의 위치(pos)를 반환한다.) - [data = pos+8(로그 데이터의 길이) / pos+8 ~ data, 실제 데이터]로 구성된다.
6. 인덱스 만들기 : [internal/log/index.go]  - 인덱스는 0부터 숱서대로 로그의 순서를 붙이고(인덱스 오프셋), 해당 인덱스의 위치(pos)를 저장한다. pos값을 알면 실제 로그 기록을 찾을 수 있다.
7. 세그먼트 만들기 : [internal/log/segment.go] 세그먼트는 스토어와 인덱스를 감싸고 둘 사이의 작업을 조율한다. 예를 들어 로그가 활성 세그먼트에 레코드를 추가할 때, 세그먼트는 데이터를 스토어에 쓰고 새로운 인덱스 항목을 인덱스에 추가한다. 읽을 때도 마찬가지이다. 세그먼트는 인덱스에서 인덱스 항목을 찾고 스토어에서 데이터를 가져온다.
8. 로그의 구현: [internal/log/log.go]
#### 4. gRPC 요청 처리
9. gRPC 서비스 정의하기 : [/api/v1/log.proto] - gRPC란 관련이 있는 RPC 엔드포인트들을 묶은 그룹이다. 어떤 관련이 있는지는 개발자가 판단한다. 흔한 예로는 RESTful에서 같은 자원에 대해 작업하는 엔드포인트들을 그룹으로 묶는 경우가 있다. 좀 더 일반적으로 말하자면, 어떠한 문제를 해결하는 데 필요한 엔드포인트들이다. 우리가 만드는 서비스의 목적은 사용자가 자신들의 로그에 읽고 쓸수 있게 하는 것이다. 
gRPC 서비스를 만든다는 것은 서비스를 protobuf로 정의하고, 프로토콜 버퍼를 클라이언트와 서버로 된 코드로 컴파일하여 구현하는 것이다. 레코드 메시지를 정의했떤 log.proto 파일을 열어서 서비스 정의를 기존 메시지 위에 추가한다.
10. gRPC 플러그인으로 컴파일하기 
- gRPC 패키지 설치
```
$ go install google.golang.org/protobuf/cmd/protoc-gen-go
$ go install google.golang.org/grpc/cmd/protoc-gen-go-grpc

```
- (생략 gRPC 컴파일 명령어 입력 오류로 log.pb.go가 생성되지 않은 것 같음)Makefile 파일의 compile 타깃을 수정하여 gRPC 플로그인을 활성화하고 gRPC 서비스를 컴파일하게 한다. 프로토콜 버퍼도 고 코드로 다시 컴파일 해야 된다. message 타입이 추가 됐기 때문이다. 
```
$ make compile 
```

11. gRPC 서버 구현 : [/internal/server/server.go]
- 컴파일러가 서버 측 로그 서비스 구현 API를 생성했으므로, 서버를 구현하려면 구조체를 만들고 protobuf에 정의해둔 서비스에 맞는 구조체의 메서드를 구현한다. 
- internal 패키지는 고에서 마법과 같은 패키지로, 오직 가까운 코드에서만 임포트할 수 있다. 예를 들어 a/b/c/internal/d/e/f 의 코드는 /a/b/c/ 디렉터리와 그 아래 코드에서만 임포트할 수 있다. /a/b/g 디렉터리의 코드는 임포트할 수 없다. server라는 패키지 명에 서버를 구현한다. 먼저 서버 자료형을 정의하고, 서버 인스턴스를 만드는 팩토리 함수를 만들겠다.

12. gRPC 에러 처리 : [/api/v1/error.go]
- 클라이언트가 메시지를 소비하려고 한 요청이 실패했다면, 서버가 메시지를 찾지 못했을까? 서버가 예상하지 못한 실패일까? 서버는 이러한 정보를 상태 코드로 전달한다. 고객 역시 어떻게 애플리케이션이 실패했는지 알아야 한다. gRPC는 에러 처리를 잘 지원한다. Go의 gRPC 구현은 status 패키지 덕분에 에러에 상태 코드를 포함한 그 어떤 데이터도 추가할 수 있다. 상태 코드를 포함한 에러를 생성하려면 status 패키지의 Error() 함수에 codes 패키지의 코드를 전달한다. 이 상태 코드는 각자의 에러 자료형과 매칭된다. 에러에 첨부한 상태 코드는 codes 패키지에 정의된 코드여야 한다. gRPC가 지원하는 모든 프로그래밍 언어는 이 상태 코드가 같다.

13. 서버 등록 : [internal/server/server.go]
- 지금까지 서버 구현 과정에서 아직 gRPC에 관한 부분은 없었다. 서비스가 gRPC로 작동하려면 세단계가 필요하며, 이제 두 단계만 해결하면 된다. 먼저 gRPC 서버를 만들고, 서비스를 등록한다. 마지막 단계는 서버에 연결하려는 요청을 받는 리스터를 추가하는 것이다. 
server.go 파일에 NewGRPCServer() 함수를 추가하여 서비슬르 인스턴스화하고, gRPC 서버를 생성하며, 서비스를 서버에 등록할 수 있게 한다. 사용자는 연결 요청을 수락하는 리스너만 추가하면 되는 gRPC 서버를 가진다.

##### 5. 서비스 보안
###### CFSSL로 나만의 CA(인증기관) 작동하기
14. [test/ca-csr.json] : 파일을 만들고 JSON을 넣는다. CA에 관한 일반적인 정보를 담은 설정 파일이다.
- CA를 초기화하고 인증서를 생성하려면 cfssl에 다양한 설정 파일을 전달해야 한다. CA 생성과 서버 인증서 생성을 위한 각각의 설정 파일과, CA에 관한 일반적인 정보를 담은 설정 파일이 필요하다.
cfssl은 이 파일로 CA의 인증서를 설정한다. CN은 Common Name을 뜻하며 "My Awesome CA"라고 이름 붙였다. key는 인증서 서명에 사용할 알고리즘과 키의 크기를 담고 있다. names는 인증서에 추가할 다양한 이름 정보이다. names의 각 객체는 최소한 하나 이상의 "C"(나라),"L"(지역),"O"(조직),"OU"(부서, 예를 들어 key를 소유한 부서) 또는 "ST"(주)가 있어야 하며 하나 이상 조합할 수도 있다.
15. [/test/ca-config.json] : CA의 정책을 정의하는 JSON이다.
- CA가 어떤 인증설르 발행할지에 관한 설정이다. signing 부분은 서명 정책에 대한 설정이다. 설정대로 만들어지는 CA는 클라이언트와 서버의 인증서를 생성할 수 있고 생성한 인증서는 1년 뒤에 만료되며 디지털 서명, 암호화 키, 인증에 사용할 수 있다.
16. [/test/server-csr.json] : cfssl은 이 설정 파일로 서버 인증설르 설정한다. hosts 필드는 인증서가 유효한 도메인명을 담고 있으며, 로컬 네트워크에서 서비스를 실행하기에 127.0.0.1 과 localhost를 넣어두었다.
17. Makefile을 업데이트하여 cfssl과 cfssljson을 사용해서 인증서를 생성한다.
- CONFIG_PATH 변수는 생성한 인증서를 저장할 위치이다. init 타깃에서 해당 디렉터리를 생성한다. 파일 시스템의 변하지 않는, 알려진 위치에 두면 코드에서 인증서를 찾고 사용하기 편리하다. gencert 타깃은 cfssl 도구와 우리가 추가한 설정 파일들을 사용하여 CA와 서버에서 쓸 인증서와 개인 키를 생성한다.
18. [/internal/config/files.go] - 테스트에서 설정 파일들을 자주 참조하므로 별도의 패키지에 생성한 파일들의 경로를 변수에 넣어두면 참조하기 더 쉽다.
19. [/internal/config/tls.go] - 인증서와 키 파일들로 *tls.Configs들을 만든다.
20. tls를 사용해서 테스트를 할 수 있도록 server_test.go의 setupTest() 함수의 코드를 바꾼다.
- 클라이언트가 CA를 사용하여 서버의 인증서를 검증하도록 한다. 서버 인증서가 다른 인증 기관에서 만든 것이라면, 즉, 클라이언트가 가진 CA로 인증서를 검증할 수 없다면, 클라이언트는 서버를 신뢰할 수 없기에 연결하지 않는다. 
