# 프로젝트 구조(각 단계별로 테스트 코드를 추가했다.)
## PART I
#### 1. 프로젝트 기본 세팅
1. 커밋 로그 프로토타입 만들기[/LetsGo/internal/server/log.go]
2. HTTP의 JSON 만들기[/LetsGo/internal/server/http.go]
#### 2. 프로토콜 버퍼와 구조체
3. 프로토콜 버퍼로 도메인 자료형 정의하기[/StructureDataWithProtobuf/api/v1/log.proto]
- [/LetsGo/internal/server/log.go] 의 Record 자료형을 protobuf 메시지로 문법에 맞게 바꿔준다.
4. protobuf가 바뀔 때마다 컴파일해야 하므로 Makefile 파일에 compile 이라는 타깃을 만들어두면 편리하다. [/StructureDataWithProtobuf]에 Makefile을 만든다.
#### 3. 로그 패키지 작성
5. 스토어 만들기 : 로그 패키지를 위한 [/internal/log/store.go] 코드를 작성한다. store 구조체는 활성 세그먼트 파일에 접근하는 포인터 필드를 포함한 해당 저장파일에 대한 정보를 가진다. store 구조체를 통해서 레코드를 파일에 기록한다.(로그를 기록할 때 해당 로그의 위치(pos)를 반환한다.) - [data = pos+8(로그 데이터의 길이) / pos+8 ~ data, 실제 데이터]로 구성된다.
6. 인덱스 만들기 : [internal/log/index.go]  - 인덱스는 0부터 숱서대로 로그의 순서를 붙이고(인덱스 오프셋), 해당 인덱스의 위치(pos)를 저장한다. pos값을 알면 실제 로그 기록을 찾을 수 있다.
7. 세그먼트 만들기 : [internal/log/segment.go] 세그먼트는 스토어와 인덱스를 감싸고 둘 사이의 작업을 조율한다. 예를 들어 로그가 활성 세그먼트에 레코드를 추가할 때, 세그먼트는 데이터를 스토어에 쓰고 새로운 인덱스 항목을 인덱스에 추가한다. 읽을 때도 마찬가지이다. 세그먼트는 인덱스에서 인덱스 항목을 찾고 스토어에서 데이터를 가져온다.
8. 로그의 구현: [internal/log/log.go]
#### 4. gRPC 요청 처리
9. gRPC 서비스 정의하기 : [/api/v1/log.proto] - gRPC란 관련이 있는 RPC 엔드포인트들을 묶은 그룹이다. 어떤 관련이 있는지는 개발자가 판단한다. 흔한 예로는 RESTful에서 같은 자원에 대해 작업하는 엔드포인트들을 그룹으로 묶는 경우가 있다. 좀 더 일반적으로 말하자면, 어떠한 문제를 해결하는 데 필요한 엔드포인트들이다. 우리가 만드는 서비스의 목적은 사용자가 자신들의 로그에 읽고 쓸수 있게 하는 것이다. 
gRPC 서비스를 만든다는 것은 서비스를 protobuf로 정의하고, 프로토콜 버퍼를 클라이언트와 서버로 된 코드로 컴파일하여 구현하는 것이다. 레코드 메시지를 정의했떤 log.proto 파일을 열어서 서비스 정의를 기존 메시지 위에 추가한다.
10. gRPC 플러그인으로 컴파일하기 
- gRPC 패키지 설치
```
$ go install google.golang.org/protobuf/cmd/protoc-gen-go
$ go install google.golang.org/grpc/cmd/protoc-gen-go-grpc

```
- Makefile 파일의 compile 타깃을 수정하여 gRPC 플로그인을 활성화하고 gRPC 서비스를 컴파일하게 한다. 프로토콜 버퍼도 고 코드로 다시 컴파일 해야 된다. message 타입이 추가 됐기 때문이다. 

11. gRPC 서버 구현 : [/internal/server/server.go]
- 컴파일러가 서버 측 로그 서비스 구현 API를 생성했으므로, 서버를 구현하려면 구조체를 만들고 protobuf에 정의해둔 서비스에 맞는 구조체의 메서드를 구현한다. 
- internal 패키지는 고에서 마법과 같은 패키지로, 오직 가까운 코드에서만 임포트할 수 있다. 예를 들어 a/b/c/internal/d/e/f 의 코드는 /a/b/c/ 디렉터리와 그 아래 코드에서만 임포트할 수 있다. /a/b/g 디렉터리의 코드는 임포트할 수 없다. server라는 패키지 명에 서버를 구현한다. 먼저 서버 자료형을 정의하고, 서버 인스턴스를 만드는 팩토리 함수를 만들겠다.

12. gRPC 에러 처리 : [/api/v1/error.go]
- 클라이언트가 메시지를 소비하려고 한 요청이 실패했다면, 서버가 메시지를 찾지 못했을까? 서버가 예상하지 못한 실패일까? 서버는 이러한 정보를 상태 코드로 전달한다. 고객 역시 어떻게 애플리케이션이 실패했는지 알아야 한다. gRPC는 에러 처리를 잘 지원한다. Go의 gRPC 구현은 status 패키지 덕분에 에러에 상태 코드를 포함한 그 어떤 데이터도 추가할 수 있다. 상태 코드를 포함한 에러를 생성하려면 status 패키지의 Error() 함수에 codes 패키지의 코드를 전달한다. 이 상태 코드는 각자의 에러 자료형과 매칭된다. 에러에 첨부한 상태 코드는 codes 패키지에 정의된 코드여야 한다. gRPC가 지원하는 모든 프로그래밍 언어는 이 상태 코드가 같다.

13. 서버 등록 : [internal/server/server.go]
- 지금까지 서버 구현 과정에서 아직 gRPC에 관한 부분은 없었다. 서비스가 gRPC로 작동하려면 세단계가 필요하며, 이제 두 단계만 해결하면 된다. 먼저 gRPC 서버를 만들고, 서비스를 등록한다. 마지막 단계는 서버에 연결하려는 요청을 받는 리스터를 추가하는 것이다. 
server.go 파일에 NewGRPCServer() 함수를 추가하여 서비슬르 인스턴스화하고, gRPC 서버를 생성하며, 서비스를 서버에 등록할 수 있게 한다. 사용자는 연결 요청을 수락하는 리스너만 추가하면 되는 gRPC 서버를 가진다.
