# Go를 사용한 분산서비스 개발
소프트웨어 분야에서 Go가 가장 큰 영향을 끼친 분야는 분산시스템이 아닐까? 도커, 쿠버네티스, etcd, 프로메테우스와 같은 프로젝트들은 고로 개발되었다. 
이 프로젝트를 통해서 Go를 사용한 분산시스템을 만들어보고, 이 과정에서 얻은 아이디어를 바탕으로 나만의 소프트웨어를 개발해보고자 한다.

## PART I
#### 1. 프로젝트 시작

#### 2. 프로토콜 버퍼와 구조체
분산 서비스에서 서비스들은 네트워크로 통신한다. 구조체와 같은 데이터를 네트워크로 보내려면 우선 데이터를 전송할 수 있는 형태로 인코딩해야 한다. 대표적인 형태가 JSON이다. public API 또는 클라이언트를 통제할 수 없는 프로젝트를 만든다면 JSON을 선택한다. JSON은 사람이 읽기에도 컴퓨터가 파싱하기에도 좋다. 하지만 private API 또는 클라이언트를 통제할 수 있는 상황이라면 JSON 보다 더 나은 데이터 구조화와 전송 방식을 택할 수 있다. 생산성이 더 높으면서 빠르고 기능도 많으며 버그도 적은 서비스를 만들 수 있는 인코딩 방식말이다.
그게 바로 프로토콜 버퍼(protocol buffer, 이하 protobuf)이다. 구글에서 만든 protobuf는 언어와 플랫폼에 상관없이 쓸 수 있고 확장할 수 있는, 데이터를 구조화하고 직렬화하는 메커니즘이다. protobuf의 장점은 다음과 같다.
- 자료형 안정성 보장
- 스키마 위반 방지
- 빠른 직렬화
- 하위 호환성 제공

protobuf를 사용하면 데이터 구조를 정의할 수 있고, protobuf가 지원하는 많은 언어의 코드로 컴파일할 수 잇으며, 이후 구조화된 데이터를 다른 데이터 스트림에 쓰거나 읽을 수 있다. 프로토콜 버퍼는 마이크로서비스와 같은 두 시스템 사이에서 통신하기에 좋다. 구글이 고성능 RPC 프레임워크를 개발하고자 gRPC를 만들 때 protobuf를 사용한 이유이다.

##### 2.1 프로토콜 버퍼를 쓰는 이유
- 일관된 스키마 : protobuf로 의미하는 바(symentics)를 인코딩하고 서비스 전반에 걸쳐 사용하면 전체 시스템의 일관성이 보장된다. 
- 버전 관리 제거 : 구글이 protobuf를 만든 이유 중 하나는 버전을 확인할 필요성을 없애고 다음과 같은 지저분한 코드작성을 피하려는 것이다. 
```
if (version ==3) {
    ...
} else if (version > 4) {
    if (version == 5){
        ...
    }
    ...
}

```
- 줄어드는 보일러플레이트 코드
- 확장성
- 언어 불가지론 : 특정 언어에 국한되지 않는다. 서로 다른 언어로 만들어진 서비스 간에 통신할 때 별도의 작업이 필요 없다.
- 성능 : 고성능이며 페이로드가 적고, 직렬화할 때 JSON 보다 6배나 빠르다.

##### 2.2 프로토콜 버퍼 컴파일러 설치하기
```
// 내 시스템에서는 아래와 같은 명령으로 protoc 을 설치했다.
$ sudo apt install protobuf-compiler
$ sudo apt install protoc-gen-go
```
- protoc --version 명령으로 protobuf 컴파일러가 제대로 설치됐는지 확인할 수 있다.
- *.proto 파일 Go 코드로 컴파일하기. 
```
$ protoc [proto 파일 경로] --go_out=. --go_opt=paths=source_relative --proto_path=.
```

#### 3. 로그 패키지 작성
로그는 분산 서비스를 만드는 가장 중요한 도구이다. 미리 쓰기 로그(로그 선행 기입, write-ahead log, WAL), 트랜잭션 로그, 커밋 로그 등으로 부르는 로그는 스토리지 엔진, 메시지 큐, 버전 컨트롤, 복제(replication)와 합의 알고리즘(consensus algorithm)의 핵심이다. 분산 시스템을 만들며 마주치는 많은 무제는 로그로 해결할 수 있다. 직접 로그를 만들어보면 다음과 같은 내용을 배울 수 있다.
- 로그를 이요해 문제를 해결하거나, 어려운 문제를 좀 더 쉽게 만드는 방법
- 기존의 로그 기반 시스템을 변경하거나, 새로운 로그 기반 시스템을 만드는 방법
- 데이터를 효율적으로 읽고 쓰는 스토리지 엔진을 만드는 방법
- 시스템 오류에도 데이터 손실을 막는 방법
- 데이터를 디스크에 저장하기 위해 인코딩하거나 자신만의 와이어 프로토콜을 만들고 애플리케이션 간에 전송하는 방법

##### 3.1 로그의 강력함
파일 시스템이나 데이터베이스의 스토리지 엔진 개발자들은 시스템의 무결성을 높이고자 로그를 사용한다. 예를 들어, ext 파일 시스템의 저널, PostgreSQL과 같은 데이터베이스에서 사용하는 WAL, 리액트와 함께 사용하는 리덕스, 자바스크립트 라이브러리는 변경사항을 객체로 로그에 저장하고, 이러한 변경 사항을 순수 함수로 처리하여 애플리케이션의 상태를 업데이트한다. 이러한 예시로 보듯이 로그는 순서가 있는 데이터를 저장, 공유, 처리할 때 사용한다. 하나의 도구로 데이터베이스를 복제하고, 분산 서비스를 조율하며, 프런트엔드 애플리케이션의 상태를 관리할 수 있다. 시스템의 변경사항을 분리할 수 없는 단위의 연산까지 쪼개고 나눈 다음에 로그로 저장, 공유, 처리할 수 있다면 분산 서비스에서의 문제를 비롯한 많은 문제를 해결할 수 있다.
완벽한 로그는 마지막 상태를 포함한, 존재했던 모든 상태를 가지며, 이러한 로그만 있으면 복잡해보이던 기능도 얼마든지 만들 수 있다. 

##### 3.2 로그의 작동 원리
- 로그는 추가만 할 수 있는 레코드의 연속이다. 레코드는 로그의 끝에 추가하며, 보통은 최근의 로그들을 오래된 레코드부터 읽는다. 어떠한 데이터라도 로그로 저장할 수 있다. 우리는 로그라는 표현을 사람이 읽을 문자열이라는 의미로 써왔다. 하지만 로그 시스템 사용자가 많아지면서 다른 프로그램이 읽을 수 있는, 바이너리로 인코딩된 메시지라는 의미로 바뀌었다. 
우리가 사용할 로그 또는 레코드는 특정 자료형의 데이터를 의미하지 않는다. 로그에 레코드를 추가하면, 로그는 레코드에 고유하면서 순차적인 오프셋 숫자를 할당하는데, 이는 레코드의 ID와 같다. 로그는 레코드의 오프셋과 생성 시간으로 정렬된 데이터베이스 테이블과 같다.
- 로그를 구현하면서 마주치는 첫 번째 문제는 무한한 용량의 디스크는 없다는 점이다. 파일 하나에 끝없이 추가할 수 없으므로 로그를 여러 개의 세그먼트로 나눈다. 로그가 커지면, 이미 처리를 마쳤거나 다른 공간에 별도로 보관한 오래된 세그먼트부터 지우면서 디스크 공간을 확보한다. 서비스는 계속 새로운 세그먼트를 만들기도 하고 세그먼트로부터 데이터를 소비하기도 한다. 이때 고루틴들이 같은 데이터에 접근하더라도 충돌이 거의 발생하지 않는다.
- 세그먼트 목록에는 항상 하나의 활성 세그먼트(active segment)가 있다. 유일하게 레코드를 쓸 수 있는 세그먼트이다. 
- 세그먼트는 저장 파일과 인덱스 파일로 구성된다. 인덱스 파일은 레코드의 오프셋을 저장 파일의 실제 위치로 매핑해서 빠르게 읽을 수 있도록 한다. 특정 오프셋의 레코드를 읽으려면 먼저 인덱스 파일에서 원하는 레코드의 저장 파일에서 위치를 알아내고, 저장 파일에서 해당 위치의 레코드를 읽는다. 인덱스 파일은 오프셋과 저장 파일에서의 위치라는 두 필드만을 가지므로 저장소 파일보다 훨씬 작다. 따라서 메모리 맵 파일로 만들어서 파일 연산이 아닌 메모리 데이터를 다루듯 빠르게 만들 수 있다.

##### 3.3 로그 만들기
저장 파일과 인덱스 파일부터 하나씩 차근차근 만들고 세그먼트를 만든 다음 마지막으로 로그를 만든다. 만들어나가는 단계별로 테스트도 작성한다. 로그(log)는 레코드, 레코드 저장 파일, 세그먼트라는 추상적인 데이터 자료형을 아우르는 표현이기에 다음과 같이 용어들을 정리한다.
- 레코드 : 로그에 저장한 데이터
- 저장 파일 : 레코드를 저장하는 파일
- 인덱스 파일 : 인덱스를 저장하는 파일
- 세그먼트 : 저장 파일과 인데스 파일을 묶어서 말하는 추상적 개념
- 로그 : 모든 세그먼트를 묶어서 말하는 추상적 개념