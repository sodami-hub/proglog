# Go를 사용한 분산서비스 개발
소프트웨어 분야에서 Go가 가장 큰 영향을 끼친 분야는 분산시스템이 아닐까? 도커, 쿠버네티스, etcd, 프로메테우스와 같은 프로젝트들은 고로 개발되었다. 
이 프로젝트를 통해서 Go를 사용한 분산시스템을 만들어보고, 이 과정에서 얻은 아이디어를 바탕으로 나만의 소프트웨어를 개발해보고자 한다.

## PART I
#### 1. 프로젝트 시작

#### 2. 프로토콜 버퍼와 구조체
분산 서비스에서 서비스들은 네트워크로 통신한다. 구조체와 같은 데이터를 네트워크로 보내려면 우선 데이터를 전송할 수 있는 형태로 인코딩해야 한다. 대표적인 형태가 JSON이다. public API 또는 클라이언트를 통제할 수 없는 프로젝트를 만든다면 JSON을 선택한다. JSON은 사람이 읽기에도 컴퓨터가 파싱하기에도 좋다. 하지만 private API 또는 클라이언트를 통제할 수 있는 상황이라면 JSON 보다 더 나은 데이터 구조화와 전송 방식을 택할 수 있다. 생산성이 더 높으면서 빠르고 기능도 많으며 버그도 적은 서비스를 만들 수 있는 인코딩 방식말이다.
그게 바로 프로토콜 버퍼(protocol buffer, 이하 protobuf)이다. 구글에서 만든 protobuf는 언어와 플랫폼에 상관없이 쓸 수 있고 확장할 수 있는, 데이터를 구조화하고 직렬화하는 메커니즘이다. protobuf의 장점은 다음과 같다.
- 자료형 안정성 보장
- 스키마 위반 방지
- 빠른 직렬화
- 하위 호환성 제공

protobuf를 사용하면 데이터 구조를 정의할 수 있고, protobuf가 지원하는 많은 언어의 코드로 컴파일할 수 잇으며, 이후 구조화된 데이터를 다른 데이터 스트림에 쓰거나 읽을 수 있다. 프로토콜 버퍼는 마이크로서비스와 같은 두 시스템 사이에서 통신하기에 좋다. 구글이 고성능 RPC 프레임워크를 개발하고자 gRPC를 만들 때 protobuf를 사용한 이유이다.

##### 2.1 프로토콜 버퍼를 쓰는 이유
- 일관된 스키마 : protobuf로 의미하는 바(symentics)를 인코딩하고 서비스 전반에 걸쳐 사용하면 전체 시스템의 일관성이 보장된다. 
- 버전 관리 제거 : 구글이 protobuf를 만든 이유 중 하나는 버전을 확인할 필요성을 없애고 다음과 같은 지저분한 코드작성을 피하려는 것이다. 
```
if (version ==3) {
    ...
} else if (version > 4) {
    if (version == 5){
        ...
    }
    ...
}

```
- 줄어드는 보일러플레이트 코드
- 확장성
- 언어 불가지론 : 특정 언어에 국한되지 않는다. 서로 다른 언어로 만들어진 서비스 간에 통신할 때 별도의 작업이 필요 없다.
- 성능 : 고성능이며 페이로드가 적고, 직렬화할 때 JSON 보다 6배나 빠르다.

##### 2.2 프로토콜 버퍼 컴파일러 설치하기
```
// 내 시스템에서는 아래와 같은 명령으로 protoc 을 설치했다.
$ sudo apt install protobuf-compiler
$ sudo apt install protoc-gen-go
```
- protoc --version 명령으로 protobuf 컴파일러가 제대로 설치됐는지 확인할 수 있다.
- *.proto 파일 Go 코드로 컴파일하기. 
```
$ protoc [proto 파일 경로] --go_out=. --go_opt=paths=source_relative --proto_path=.
```

#### 3. 로그 패키지 작성
